はい、承知しました。未経験者にも分かりやすいように、より詳細な説明を省略せずに提供いたします。

# 目次

- [1. ライブラリのインポート](#1-ライブラリのインポート)
- [2. パラメータの設定](#2-パラメータの設定)
- [3. データの読み込み](#3-データの読み込み)
- [4. ワーク接合部の削除](#4-ワーク接合部の削除)
- [5. 二値化によるマスクの作成](#5-二値化によるマスクの作成)
- [6. エッジ検出とテクスチャ検出の改良](#6-エッジ検出とテクスチャ検出の改良)
- [7. ラベリング処理と欠陥候補の中心座標の取得](#7-ラベリング処理と欠陥候補の中心座標の取得)
- [8. ワークのエッジと重なっている欠陥候補の除外処理](#8-ワークのエッジと重なっている欠陥候補の除外処理)
- [9. 欠陥候補の保存](#9-欠陥候補の保存)

# 1. ライブラリのインポート

この項目では、プロジェクトで使用する必要なライブラリをインポートしています。ライブラリとは、特定の機能をまとめたプログラムの集合体です。

目的:
- 画像処理や機械学習に必要なライブラリを準備する
- これらのライブラリを使用することで、複雑な処理を簡単に実行できるようにする

説明:
1. `os`: ファイルやディレクトリの操作に使用します。例えば、ファイルのパスを操作したり、ディレクトリを作成したりするのに使います。

2. `cv2`: OpenCVライブラリです。画像処理の主要な機能を提供します。画像の読み込み、保存、変換、フィルタリングなど、多くの画像処理タスクに使用します。

3. `numpy`: 数値計算や配列操作に使用します。画像は数値の配列として扱われるため、画像処理においても重要な役割を果たします。

4. `skimage`: scikit-imageライブラリです。画像処理のための追加機能を提供します。フィルタリング、特徴検出、画像変換など、より高度な画像処理機能を提供します。

5. `matplotlib`: グラフや画像の表示に使用します。処理結果を視覚化する際に役立ちます。

これらのライブラリをインポートすることで、以降のコードで各ライブラリの機能を簡単に使用できるようになります。

# 2. パラメータの設定

この項目では、プロジェクト全体で使用する様々なパラメータを設定しています。パラメータとは、プログラムの動作を制御する値のことです。

目的:
- 画像処理や欠陥検出に必要な各種パラメータを一箇所で管理する
- パラメータを変更することで、プログラムの挙動を簡単に調整できるようにする

説明:
1. 入出力ディレクトリのパス:
   - `input_data_dir`: 入力データが格納されているディレクトリのパス
   - `output_data_dir`: 処理結果を保存するディレクトリのパス

2. NGラベルの定義:
   - `ng_labels`: 欠陥の種類を示すラベルのリスト（例：鋳巣、凹み、亀裂）

3. テンプレート画像のパス:
   - `template_dir`: テンプレート画像が格納されているディレクトリのパス
   - `right_template_path`: 右側ワークのテンプレート画像のパス
   - `left_template_path`: 左側ワークのテンプレート画像のパス

4. 画像処理パラメータ:
   - `crop_width`: ワーク接合部を削除するための幅（ピクセル単位）
   - `threshold_value`: 二値化の閾値
   - `kernel_size`: モルフォロジー演算に使用するカーネルのサイズ
   - `iterations_open`: 膨張処理の繰り返し回数
   - `iterations_close`: 収縮処理の繰り返し回数
   - `gaussian_kernel_size`: ガウシアンブラーのカーネルサイズ
   - `canny_min_threshold`: Cannyエッジ検出の最小閾値
   - `canny_max_threshold`: Cannyエッジ検出の最大閾値
   - `sigma`: ガウシアンブラーの標準偏差

5. 欠陥サイズの範囲:
   - `min_defect_size`: 検出する最小欠陥サイズ（ピクセル単位）
   - `max_defect_size`: 検出する最大欠陥サイズ（ピクセル単位）

6. テクスチャ検出のパラメータ:
   - `texture_threshold`: テクスチャの変化を検出するための閾値

これらのパラメータを適切に設定することで、画像処理の精度や欠陥検出の感度を調整することができます。プログラムの動作を変更したい場合は、これらのパラメータを変更することで対応できます。

# 3. データの読み込み

この項目では、入力データを読み込む処理を行っています。画像処理を行うためには、まず画像データを読み込む必要があります。

目的:
- 元画像とキーエンス処理済み画像のペアを効率的に読み込む
- 読み込んだ画像データを後続の処理で使用できるように整理する

説明:
1. `load_origin_keyence_images`関数:
   - この関数は指定されたディレクトリから画像ペアを読み込みます。
   - 処理の流れ：
     a. 指定されたディレクトリ内のファイルを走査します。
     b. ファイル名に"Normal"が含まれる画像を元画像として、"Shape"が含まれる画像をキーエンス処理済み画像として識別します。
     c. 同じワークの元画像とキーエンス処理済み画像をペアにして、リストに格納します。
   - この関数により、大量の画像データを効率的に読み込むことができます。

2. NG画像とOK画像の読み込み:
   - `ng_images_label1`, `ng_images_label2`, `ng_images_label3`: それぞれ異なる種類の欠陥（例：鋳巣、凹み、亀裂）を含むNG画像のペアを格納するリスト
   - `ok_images`: 欠陥のないOK画像のペアを格納するリスト
   - これらのリストを作成することで、後続の処理で欠陥の種類ごとに異なる処理を適用したり、OK画像とNG画像を比較したりすることが可能になります。

この処理により、大量の画像データを構造化された形で読み込むことができ、後続の画像処理や機械学習のタスクを効率的に実行することができます。

# 4. ワーク接合部の削除

この項目では、画像からワークの接合部を削除する処理を行っています。ワーク接合部とは、2つの部品が接合されている部分のことで、この部分は欠陥検出の精度に悪影響を与える可能性があるため、除去します。

目的:
- 不要な接合部を除去し、欠陥検出の精度を向上させる
- ワークの左右を判定し、適切な部分を切り出す

説明:
1. `template_matching`関数:
   - この関数は、テンプレートマッチングという技術を使用してワークの左右を判定します。
   - 処理の流れ：
     a. 入力画像とテンプレート画像を比較します。
     b. 最も類似度が高い位置を見つけます。
     c. その類似度のスコアと位置を返します。
   - この関数により、ワークが左側にあるか右側にあるかを判断することができます。

2. `remove_joint_part`関数:
   - この関数は、判定結果に基づいて接合部を削除します。
   - 処理の流れ：
     a. 入力画像と、キーエンス処理済み画像を読み込みます。
     b. `template_matching`関数を使用して、ワークが左右どちらにあるかを判定します。
     c. 判定結果に基づいて、適切な側から指定された幅（`crop_width`）分の画像を切り出します。
   - この関数により、接合部を除去した画像を得ることができます。

3. `process_images`関数:
   - この関数は、全ての画像ペアに対して接合部削除を実行します。
   - 処理の流れ：
     a. 入力された画像ペアのリストを順に処理します。
     b. 各ペアに対して`remove_joint_part`関数を適用します。
     c. 処理結果を新しいリストに格納します。
   - この関数により、大量の画像に対して一括で接合部削除処理を行うことができます。

4. NGとOK画像に対する処理の実行:
   - 上記の関数を使用して、NGとOK画像それぞれに対して接合部削除処理を実行します。
   - 処理結果は新しい変数（`updated_ng_images_label1`など）に格納されます。

この処理により、後続の欠陥検出処理において、接合部による誤検出を減らし、より正確な結果を得ることができます。

# 5. 二値化によるマスクの作成

この項目では、画像を二値化してマスクを作成する処理を行っています。二値化とは、画像の各ピクセルを白か黒のどちらかに変換する処理です。これにより、ワーク部分と背景を明確に区別することができます。

目的:
- ワーク部分のみを抽出し、背景を除去するためのマスクを生成する
- 後続の処理で使用する、ワークの形状を表す白黒画像（マスク）を作成する

説明:
1. `binarize_image`関数:
   - この関数は、入力画像を二値化し、さらにモルフォロジー演算を適用してマスクを生成します。
   - 処理の流れ：
     a. 入力画像がカラーの場合、グレースケールに変換します。
     b. 設定された閾値（`threshold_value`）を使用して二値化を行います。
     c. モルフォロジー演算（オープニングとクロージング）を適用して、ノイズを除去し、ワークの形状を整えます。
   - モルフォロジー演算の説明：
     - オープニング：小さなノイズを除去し、オブジェクトの境界を滑らかにします。
     - クロージング：小さな穴や隙間を埋め、オブジェクトの形状を整えます。
   - この関数により、ワークの形状を正確に表現するマスクを得ることができます。

2. `binarize_images`関数:
   - この関数は、全ての画像に対して二値化処理を実行します。
   - 処理の流れ：
     a. 入力された画像ペアのリストを順に処理します。
     b. 各ペアの元画像に対して`binarize_image`関数を適用します。
     c. 二値化された画像と元のキーエンス処理済み画像のペアを新しいリストに格納します。
   - この関数により、大量の画像に対して一括で二値化処理を行うことができます。

3. NGとOK画像に対する処理の実行:
   - 上記の関数を使用して、NGとOK画像それぞれに対して二値化処理を実行します。
   - 処理結果は新しい変数（`binarized_ng_images_label1`など）に格納されます。

この処理により作成されたマスクは、後続の処理で以下のように活用されます：
- 背景を除去し、ワーク部分のみに注目した処理を行う
- ワークの輪郭を正確に把握し、エッジ検出の精度を向上させる
- 欠陥候補の位置が実際にワーク上にあるかを確認する

二値化によるマスク作成は、画像処理の基本的かつ重要な前処理ステップであり、後続の欠陥検出の精度向上に大きく貢献します。

# 6. エッジ検出とテクスチャ検出の改良

この項目では、欠陥検出のためのエッジ検出とテクスチャ検出を行っています。エッジ検出は画像内の輝度が急激に変化する箇所を見つける処理で、テクスチャ検出は画像の局所的な模様や構造を識別する処理です。

目的:
- 小さな欠陥も含めて、より正確に欠陥を検出する
- エッジ検出だけでは見逃してしまう可能性のある欠陥をテクスチャ検出で補完する

説明:
1. `detect_edges_and_texture`関数:
   - この関数は、エッジ検出とテクスチャ変化の検出を組み合わせて欠陥を検出します。
   - 処理の流れ：
     a. マスクを適用して背景を除去します。
     b. ガウシアンブラーを適用してノイズを減らします。
     c. Cannyエッジ検出を行い、輝度の急激な変化を検出します。
     d. ラプラシアンフィルタを使用してテクスチャの変化を検出します。
     e. エッジ検出とテクスチャ検出の結果を統合します。

   - ガウシアンブラー：画像を滑らかにし、ノイズを減らす処理です。
   - Cannyエッジ検出：輝度の変化が大きい部分を検出し、エッジとして抽出します。
   - ラプラシアンフィルタ：画像の二次微分を計算し、急激な輝度変化を検出します。

   この関数により、エッジだけでなくテクスチャの変化も考慮した、より包括的な欠陥検出が可能になります。

2. パラメータの調整:
   - `gaussian_kernel_size`：ガウシアンブラーの強さを調整します。
   - `sigma`：ガウシアンブラーの広がりを制御します。
   - `canny_min_threshold`と`canny_max_threshold`：Cannyエッジ検出の感度を調整します。
   - `texture_threshold`：テクスチャ変化の検出感度を調整します。

   これらのパラメータを適切に設定することで、様々な種類や大きさの欠陥に対応できます。

この改良されたエッジ検出とテクスチャ検出により、従来のエッジ検出だけでは見逃していた可能性のある小さな欠陥や微妙な表面の変化も検出できるようになります。これは、鋳造部品の品質管理において非常に重要な改善点です。

# 7. ラベリング処理と欠陥候補の中心座標の取得

この項目では、検出された欠陥候補にラベルを付け、その中心座標を取得します。ラベリングとは、画像内の連結した領域を個別に識別し、番号を割り当てる処理です。

目的:
- 欠陥候補を個別に識別し、その位置情報を取得する
- 後続の処理で各欠陥候補を個別に分析できるようにする

説明:
1. `label_and_filter_defects`関数:
   - この関数は、欠陥候補のラベリングとフィルタリングを行います。
   - 処理の流れ：
     a. `cv2.connectedComponentsWithStats`を使用してラベリング処理を行います。
     b. マスクのエッジを除外します（`remove_mask_edges`関数を使用）。
     c. 各ラベル付けされた領域のサイズをチェックし、指定された範囲内（`min_defect_size`から`max_defect_size`）の欠陥候補のみを抽出します。
     d. 各欠陥候補の位置（x, y座標）、大きさ（幅と高さ）、中心座標を取得します。

2. `label_defects_in_images_with_edge_removal`関数:
   - この関数は、全画像に対してラベリング処理を実行します。
   - 処理の流れ：
     a. 入力された画像ペアのリストを順に処理します。
     b. 各ペアに対して`label_and_filter_defects`関数を適用します。
     c. 処理結果（二値化画像、エッジ画像、欠陥候補リスト）を新しいリストに格納します。

3. ラベリング処理の詳細:
   - 連結成分分析：隣接するピクセルのグループを一つの領域として識別します。
   - 統計情報の取得：各領域の面積、重心、外接矩形などの情報を取得します。
   - フィルタリング：サイズや位置に基づいて、欠陥候補を絞り込みます。

4. 欠陥候補の情報:
   - (x, y): 欠陥候補の左上角の座標
   - (w, h): 欠陥候補の幅と高さ
   - (cx, cy): 欠陥候補の中心座標

このラベリング処理により、画像内の各欠陥候補を個別のオブジェクトとして扱うことができるようになります。これは後続の分析や分類処理において非常に重要です。例えば、各欠陥候補の特徴を個別に抽出したり、機械学習モデルに入力したりする際に、この情報が活用されます。

# 8. ワークのエッジと重なっている欠陥候補の除外処理

この項目では、ワークのエッジと重なっている欠陥候補を除外する処理を行います。これは誤検出を減らすために重要な処理です。

目的:
- エッジ部分の誤検出を減らし、真の欠陥候補のみを抽出する
- ワークの形状に起因する誤検出を防ぐ

説明:
1. `remove_defects_on_mask_edge`関数:
   - この関数は、マスクのエッジと重なる欠陥候補を除外します。
   - 処理の流れ：
     a. マスク画像のエッジを検出します（Cannyエッジ検出を使用）。
     b. 各欠陥候補について、その外接矩形がマスクのエッジと重なっているかチェックします。
     c. エッジと重なっていない欠陥候補のみを保持します。

2. エッジ除去処理の統合:
   - 前述の`label_and_filter_defects`関数内で、この除外処理を呼び出します。
   - これにより、ラベリング処理と同時にエッジ上の欠陥候補を除外することができます。

3. エッジ除去の重要性:
   - ワークのエッジ部分は、しばしば光の反射や形状の変化により、欠陥と誤認識されやすい領域です。
   - この処理により、そうした誤検出を大幅に減らすことができます。
   - 結果として、真の欠陥候補にのみ注目することが可能になり、検出精度が向上します。

4. 処理の適用:
   - NGとOK画像の両方に対してこの処理を適用します。
   - 処理結果は`labeled_ng_images_label1`などの変数に格納されます。

この処理により、ワークの形状に起因する誤検出を効果的に減らすことができます。これは特に鋳造部品のような複雑な形状を持つ製品の検査において非常に重要です。真の欠陥のみを正確に検出することで、製品の品質管理の精度が大幅に向上します。

# 9. 欠陥候補の保存

この項目では、検出された欠陥候補を保存する処理を行います。これは後続の分析や機械学習のためのデータ準備として重要なステップです。

目的:
- 検出された欠陥候補を個別の画像として保存する
- 後続の分析や機械学習のトレーニングデータとして使用できるようにする

説明:
1. `save_defect_candidates`関数:
   - この関数は、検出された欠陥候補を個別に保存します。
   - 処理の流れ：
     a. 保存先のディレクトリを作成します（存在しない場合）。
     b. 元画像ごとにサブディレクトリを作成します。
     c. 各欠陥候補について：
        - 外接矩形で切り出します。
        - 100倍に拡大します。
        - 一意のファイル名で保存します。

2. `save_defects_for_all_images`関数:
   - この関数は、全ての画像の欠陥候補を保存します。
   - 処理の流れ：
     a. 入力された画像リストを順に処理します。
     b. 各画像について`save_defect_candidates`関数を呼び出します。

3. 保存処理の詳細:
   - 拡大処理：小さな欠陥も詳細に観察できるよう、100倍に拡大します。
   - ファイル名：元画像名と欠陥番号を組み合わせて一意のファイル名を生成します。
   - 画像フォーマット：PNG形式で保存し、画質の劣化を防ぎます。

この処理により、検出された欠陥候補を個別に保存し、後続の分析や機械学習に活用できる形で準備することができます。これは、鋳造部品の品質管理システムを継続的に改善し、より高精度な欠陥検出を実現するための重要なステップとなります。
